# 树
树（英语：tree）是一种抽象数据类型（ADT）
![7.0](image/7.0.png)
# 树的术语

- 节点的度：一个节点含有的子树的个数称为该节点的度；
- 树的度：一颗树中，最大的节点的度称为树的度；
- 叶节点或终端节点：度为零的节点；
- 父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
- 子节点：一个节点含有的子树的根节点称为该节点的子节点；
- 兄弟节点：具有相同父节点的节点互相称为兄弟节点；
- 节点的层次：从根节点开始定义起，根为第一层，根的子节点为第二层，以此类推；
- 树的高度或深度：树中节点的最大层次；
- 堂兄弟节点：父节点在同一层次的节点互为堂兄弟；
- 节点的祖先：从根节点到该节点所经分支上的所有节点；
- 子孙：以某一节点为根的子树中任一节点都称为该节点的子孙；
- 森林：由m（m >= 0）颗互不相交的树的集合称为森林；

# 树的种类
- 无序树：树中任意节点的子节点之间没有顺序关系
- 有序树：树中任意节点的子节点之间有顺序关系
 - - 二叉树：每个节点最多含有两个子树
 - - 完全二叉树：除最底层最后一个外其他必须有子树
 - - 满二叉树：所有叶节点都在最底层的完全二叉树
 - - 平衡二叉树：当且仅当任何节点的两颗子树的高度差不大于1的二叉树
 - - 排序二叉树：二叉搜索树
- 霍夫曼树（用于信息编码）：带权路径最短的二叉树
- B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有杜宇两个子树

# 常见的一些树的应用场景

1.xml，html等，那么编写这些东西的解析器的时候，不可避免用到树
2.路由协议就是使用了树的算法
3.mysql数据库索引
4.文件系统的目录结构
5.所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构 



# 二叉树的遍历
## 深度优先遍历和广度优先遍历
深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。

### 深度优先遍历


    先序遍历 在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树
    根节点->左子树->右子树

    def preorder(self, root):
          """递归实现先序遍历"""
          if root == None:
              return
          print root.elem
          self.preorder(root.lchild)
          self.preorder(root.rchild)

    中序遍历 在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树
    左子树->根节点->右子树

    def inorder(self, root):
          """递归实现中序遍历"""
          if root == None:
              return
          self.inorder(root.lchild)
          print root.elem
          self.inorder(root.rchild)

    后序遍历 在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点
    左子树->右子树->根节点

    def postorder(self, root):
          """递归实现后续遍历"""
          if root == None:
              return
          self.postorder(root.lchild)
          self.postorder(root.rchild)
          print root.elem

![7.1](image/7.1.png)

前序和后序在本质上都是将父节点与子结点进行分离，但并没有指明左子树和右子树的能力，因此得到这两个序列只能明确父子关系，而不能确定一个二叉树。

由二叉树的中序和前序遍历序列可以唯一确定一棵二叉树 ，由前序和后序遍历则不能唯一确定一棵二叉树

由二叉树的中序和后序遍历序列可以唯一确定一棵二叉树，由前序和后序遍历则不能唯一确定一棵二叉树 